"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUserOpForEstimation = exports.generateDummySignature = exports.generateSalt = exports.serializeUserOperation = exports.getUserOperationHash = exports.packPaymasterAndData = exports.packAccountGasLimits = exports.packUserOperation = exports.encodeFunctionCall = exports.getAccountAddress = void 0;
const ethers_1 = require("ethers");
/**
 * Calculate the counterfactual address of a GokiteAccount
 * This matches the logic in GokiteAccountFactory.getAddress()
 */
function getAccountAddress(factoryAddress, implementationAddress, owner, salt) {
    const proxyCreationCode = '0x60806040526102a88038038061001481610168565b92833981016040828203126101645781516001600160a01b03811692909190838303610164576020810151906001600160401b03821161016457019281601f8501121561016457835161006e610069826101a1565b610168565b9481865260208601936020838301011161016457815f926020809301865e86010152823b15610152577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561013a575f8091610122945190845af43d15610132573d91610113610069846101a1565b9283523d5f602085013e6101bc565b505b604051608d908161021b8239f35b6060916101bc565b50505034156101245763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b0381118382101761018d57604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b03811161018d57601f01601f191660200190565b906101e057508051156101d157602081519101fd5b63d6bda27560e01b5f5260045ffd5b81511580610211575b6101f1575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b156101e956fe60806040525f8073ffffffffffffffffffffffffffffffffffffffff7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc5416368280378136915af43d5f803e156053573d5ff35b3d5ffdfea2646970667358221220359eac519e2625610420a0e3cfdfe26e6cc711dbb451880735ac4544d4ccdcf264736f6c634300081c0033';
    const initializeCallData = encodeFunctionCall(['function initialize(address)'], 'initialize', [owner]);
    const constructorArgs = ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['address', 'bytes'], [implementationAddress, initializeCallData]);
    // Full creation code = creation code + constructor args
    const fullCreationCode = proxyCreationCode + constructorArgs.slice(2);
    return ethers_1.ethers.getCreate2Address(factoryAddress, ethers_1.ethers.zeroPadValue(ethers_1.ethers.toBeHex(salt), 32), ethers_1.ethers.keccak256(fullCreationCode));
}
exports.getAccountAddress = getAccountAddress;
/**
 * Encode function call data
 */
function encodeFunctionCall(abi, functionName, params) {
    const iface = new ethers_1.ethers.Interface(abi);
    return iface.encodeFunctionData(functionName, params);
}
exports.encodeFunctionCall = encodeFunctionCall;
/**
 * Pack user operation for hashing
 */
function packUserOperation(userOp) {
    const packed = ethers_1.ethers.AbiCoder.defaultAbiCoder().encode([
        'address', 'uint256', 'bytes', 'bytes',
        'uint256', 'uint256', 'uint256', 'uint256', 'uint256',
        'bytes'
    ], [
        userOp.sender,
        userOp.nonce,
        ethers_1.ethers.keccak256(userOp.initCode),
        ethers_1.ethers.keccak256(userOp.callData),
        userOp.callGasLimit,
        userOp.verificationGasLimit,
        userOp.preVerificationGas,
        userOp.maxFeePerGas,
        userOp.maxPriorityFeePerGas,
        ethers_1.ethers.keccak256(userOp.paymasterAndData)
    ]);
    return packed;
}
exports.packUserOperation = packUserOperation;
/**
 * Pack account gas limits into 32 bytes
 * @param verificationGasLimit Verification gas limit (16 bytes, first half)
 * @param callGasLimit Call gas limit (16 bytes, second half)
 * @returns 32 bytes packed data as hex string
 */
function packAccountGasLimits(verificationGasLimit, callGasLimit) {
    // Ensure values don't exceed uint128 (2^128 - 1)
    const uint128Max = (BigInt(1) << BigInt(128)) - BigInt(1);
    if (verificationGasLimit > uint128Max || callGasLimit > uint128Max) {
        throw new Error('Gas limit exceeds uint128 maximum');
    }
    // Pack verificationGasLimit into first 16 bytes, callGasLimit into last 16 bytes
    const verificationHex = verificationGasLimit.toString(16).padStart(32, '0'); // 16 bytes = 32 hex chars
    const callGasHex = callGasLimit.toString(16).padStart(32, '0'); // 16 bytes = 32 hex chars
    return '0x' + verificationHex + callGasHex;
}
exports.packAccountGasLimits = packAccountGasLimits;
/**
 * Pack paymaster and data
 * @param paymasterAddress Paymaster contract address (20 bytes)
 * @param paymasterVerificationGasLimit Paymaster verification gas limit (16 bytes)
 * @param postOpGasLimit Post operation gas limit (16 bytes)
 * @param paymasterData Additional paymaster data (variable length)
 * @returns Packed paymaster and data as hex string
 */
function packPaymasterAndData(paymasterAddress, paymasterVerificationGasLimit, postOpGasLimit, paymasterData = '0x') {
    if (paymasterAddress === '0x' || paymasterAddress === '0x0000000000000000000000000000000000000000') {
        return '0x';
    }
    // Ensure values don't exceed uint128 (2^128 - 1)
    const uint128Max = (BigInt(1) << BigInt(128)) - BigInt(1);
    if (paymasterVerificationGasLimit > uint128Max || postOpGasLimit > uint128Max) {
        throw new Error('Gas limit exceeds uint128 maximum');
    }
    // Remove 0x prefix if present
    const cleanAddress = paymasterAddress.startsWith('0x') ? paymasterAddress.slice(2) : paymasterAddress;
    const cleanData = paymasterData.startsWith('0x') ? paymasterData.slice(2) : paymasterData;
    // Pack: address (20 bytes) + paymasterVerificationGasLimit (16 bytes) + postOpGasLimit (16 bytes) + paymasterData
    const paymasterVerificationHex = paymasterVerificationGasLimit.toString(16).padStart(32, '0'); // 16 bytes
    const postOpHex = postOpGasLimit.toString(16).padStart(32, '0'); // 16 bytes
    return '0x' + cleanAddress + paymasterVerificationHex + postOpHex + cleanData;
}
exports.packPaymasterAndData = packPaymasterAndData;
/**
 * Get user operation hash
 */
function getUserOperationHash(userOp, entryPointAddress, chainId) {
    const packed = packUserOperation(userOp);
    const enc = ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['bytes32', 'address', 'uint256'], [ethers_1.ethers.keccak256(packed), entryPointAddress, chainId]);
    return ethers_1.ethers.keccak256(enc);
}
exports.getUserOperationHash = getUserOperationHash;
/**
 * Convert bigint values to hex strings for JSON serialization
 * Also unpacks PackedUserOperation format to legacy format for bundler compatibility
 */
function serializeUserOperation(userOp) {
    // Unpack accountGasLimits (32 bytes): verificationGasLimit (16 bytes) + callGasLimit (16 bytes)
    const accountGasLimitsHex = userOp.accountGasLimits.startsWith('0x') ? userOp.accountGasLimits.slice(2) : userOp.accountGasLimits;
    const verificationGasLimitHex = accountGasLimitsHex.slice(0, 32); // First 16 bytes (32 hex chars)
    const callGasLimitHex = accountGasLimitsHex.slice(32, 64); // Last 16 bytes (32 hex chars)
    // Unpack gasFees (32 bytes): maxPriorityFeePerGas (16 bytes) + maxFeePerGas (16 bytes)  
    const gasFeesHex = userOp.gasFees.startsWith('0x') ? userOp.gasFees.slice(2) : userOp.gasFees;
    const maxPriorityFeePerGasHex = gasFeesHex.slice(0, 32); // First 16 bytes (32 hex chars)
    const maxFeePerGasHex = gasFeesHex.slice(32, 64); // Last 16 bytes (32 hex chars)
    return {
        sender: userOp.sender,
        nonce: ethers_1.ethers.toBeHex(userOp.nonce),
        initCode: userOp.initCode,
        callData: userOp.callData,
        // Unpack to legacy format for bundler compatibility
        callGasLimit: '0x' + callGasLimitHex,
        verificationGasLimit: '0x' + verificationGasLimitHex,
        preVerificationGas: ethers_1.ethers.toBeHex(userOp.preVerificationGas),
        maxFeePerGas: '0x' + maxFeePerGasHex,
        maxPriorityFeePerGas: '0x' + maxPriorityFeePerGasHex,
        paymasterAndData: userOp.paymasterAndData,
        signature: userOp.signature
    };
}
exports.serializeUserOperation = serializeUserOperation;
// default salt is 0
function generateSalt() {
    return BigInt(2);
}
exports.generateSalt = generateSalt;
/**
 * Generate a dummy signature for gas estimation
 * The signature needs to be the correct length but doesn't need to be valid
 * Using a format that won't cause ECDSA.recover to revert
 */
function generateDummySignature() {
    return "0x59c044382c5418739ef913865b05f60050f8e587041548215aa595816dfbe77b26408ebd368bc51be61008aaef7b9b87479c91f9c297caf1e33e8c3b2de69a3b1c";
}
exports.generateDummySignature = generateDummySignature;
/**
 * Create a user operation with dummy signature for gas estimation
 */
function createUserOpForEstimation(userOp) {
    return {
        ...userOp,
        signature: generateDummySignature(),
        // Ensure paymasterAndData is set if not provided
        paymasterAndData: userOp.paymasterAndData || '0x'
    };
}
exports.createUserOpForEstimation = createUserOpForEstimation;
